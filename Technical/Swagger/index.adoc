= Swagger v2
:toc:
:toc-title: 目次
:figure-caption: 図
:table-caption: 表
:toclevels: 3
//:pagenums:
//:sectnums:
:imagesdir: images
:source-highlighter: prettify

== Swaggerとは

SwaggerとはOpenAPIに基づいた


== 使い方

=== 使い方の流れ

=== YAMLの作成

Swaggerを利用するには、まずYAMLを作成する必要がある。 +
YAMLの作成にはSwaggerが提供しているエディタを利用するのが便利である。 +

http://editor2.swagger.io/

最近新しくなった？？

=== ソースコード・ドキュメントの出力

== 対応メディアタイプ
=== produces
リソースから返却するMIMEタイプであるProducesには以下を指定することができる。

[cols="40,60", option="header"]
|====

|type
|説明

|application/json
|

|application/xml
|

|====

NOTE: 上記に挙げた以外のメディアタイプが利用できる場合においてもAPI設計として対応しないほうが無難だと思われる


=== consumes

[cols="40,60", option="header"]
|====

|type
|説明

|application/json
|

|application/xml
|

|application/octet-stream
|

|application/x-www-form-urlencoded
|

|multipart/form-data
|


|====

== Javaの型

== Validation

== サーバーサイド出力

=== spring - springboot
SpringのBootによるサーバーサイドコードの出力が可能。 +
Swaggerで出力されるサーバーサイドコードの様々な内容の調査結果を記載する。（2017/08）


== クライアント出力

=== Java - RestTemplate
SpringのRestTemplateによるクライアントサイドコードの出力が可能。 +
Swaggerで出力されるRestTemplateの様々な内容の調査結果を記載する。（2017/08）

==== 出力指定
出力時の指定は以下の通り。

[cols="30,70", option="header"]
|====

|language
|library

| java
| resttemplate

|====

===== 出力設定ファイル
ソースコード出力時にJSONの設定ファイルにて細かな設定を行うことができる。 +
その内容の一覧は以下。（Swagger Codegen Cli 2.2.3のデフォルト）

[cols="30,10,60", option="header"]
|====

|要素
|型
|説明

|modelPackage
|String
|APIで利用するモデルクラスの出力パッケージを指定

|apiPackage
|String
|API個別クライアントクラスの出力パッケージを指定

|invokerPackage
|String
|API実行のためのコアRESTクライアントの出力パッケージを指定

|serializableModel
|Boolean
|モデルクラスがSerializableを実装するかどうかを指定

|dateLibrary
|String
|日付時刻に関してどのようなライブラリもしくはクラスを利用するかを指定。joda（JodaTime）、legacy（java.utl.Date）、java8-localdatetime（Java8のjava8-LocalDateTime）、java8（Java8）

|useBeanValidation
|Boolean
|BeanValidationを利用するかどうか

|====

.実装例
[source, json]
----
{
	"modelPackage": "hoge.fuga.piyo.client.model",
	"apiPackage": "hoge.fuga.piyo.client.api",
	"invokerPackage": "hoge.fuga.piyo",
        "dateLibrary": "java8",
	"useBeanValidation": true,
	"serializableModel": true
}
----

自分の出力したいように上記をカスタマイズすることができる。 +
これより細かい内容をカスタマイズするとなるとテンプレートのカスタマイズを行うしかないように思う。


==== クラス構成

RestTemplateによるRESTクライアントは以下のようの構成でクラスが分割されている。 +

[cols="30,70", option="header"]
|====

|種類
|用途

|モデル
|リクエストもしくはレスポンスの型を定義するためのJavaBean

|API個別クライアント
|各APIを呼び出すためのRESTクライアントクラス。このクラスはSwaggerのYAML定義のタグ毎にクラスが分割されている。

|API実行クラス
|全てのAPIを実行するコアRESTクライアントのような位置づけのクラス。API個別クライアントはこのクラスを経由してREST-APIを呼び出すようになっている。このクラスは１つのみ。


|====

==== 利用方法
Swaggerにて出力されたRESTクライアントのクラス群のうち、
利用するのは上記で勝手に名付けているAPI個別クライアントとなるわけだが、
@Componentが付いているため利用したいクラスでインジェクションして利用することができる。 +
 +
このAPI個別クライアントは、内部でAPI実行クラス（ApiClient）をコンストラクタインジェクションで
もらうようになっているためAPI実行クラスが初期化されていなければ利用できない。 +
 +
さらにAPI実行クラスはRestTemplateをコンストラクタインジェクションにてもらうようになっているため、
利用するには自分自身でRestTemplateをDIコンテナに登録しておかなければならない。とはいえ、以下のようなコードを定義するだけである。

[source, java, numbered]
----
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class RestClientConfiguration {

  @Bean
  public RestTemplate getRestTemplate() {
   return new RestTemplate();
  }

}
----

このようにして、自分で利用するRestTemplateを生成することができるためインターセプター等を自分で設定して
自動生成したクラスで処理することができる。とても利便性をよく考えられていると思うと同時に勉強になる。


==== 処理内容

RestTemplate
